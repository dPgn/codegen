// Nodes that don't take arguments are macro expansions with empty __VA_ARGS__, which, I believe is
// not legal C++14. This works just fine for me using the CLang version behind Apple's c++ command,
// whatever that might be, but I suppose some kind of a kludge will be needed for portability.

X(arithmetic, Add, word, word)
X(arithmetic, Sub, word, word)
X(arithmetic, Mul, word, word)
X(arithmetic, Div, word, word)
X(node, DivMod, word, word, word, word) // the modulo is written in the first argument, second is the high word of the dividend
X(node, MulWiden, word, word, word) // writes the high half of the result to the first argument

X(compare, Gt, word, word)
X(compare, Lt, word, word)
X(compare, Gte, word, word)
X(compare, Lte, word, word)
X(compare, Eq, word, word)
X(compare, Neq, word, word)

X(arithmetic, And, word, word)
X(arithmetic, Or, word, word)
X(arithmetic, Xor, word, word)

X(arithmetic, Neg, word)
X(arithmetic, Not, word)

X(node, Move, word, word) // destination, source

// Memory access can be written either as
// Move(Mem(type, dstaddr), src) and Mem(type, srcaddr)
// or
// St(type, dstaddr, src) and Ld(type, srcaddr).
// The sole difference between Mem and Ld is that Ld is read-only; it cannot, for example, be used
// as the first (destination) operand of a Move. Using Mem is typically more intuitive in a client
// application and is easier to map to CISC ISAs, while Ld and St are easier handle in optimizers
// and map directly to native instructions of RISC processors. Client application can freely mix
// the two equivalent styles, while internally everything is converted into whatever better suits
// the task at hand.
X(node, Mem, word, word) // type, address
X(node, Ld, word, word) // type, address
X(node, St, word, word, word) // type, address, value

// When a value must be in a register, it is wrapped in a node Reg. Semantically, a Reg is the same
// as its first (value) argument. The second argument is an architecture specific identifier that
// identifies either a specific register or a group of registers the actual register must be chosen
// from by the register allocator. After the register allocation phase, when IR code is passed to
// the architecture specific code generator, every Reg node must have an id that specifies a single
// register. Any Reg nodes coming from the client application are ignored by substituting them with
// their first (value) arguments; Reg nodes are only meant to be used internally by the library.
X(node, Reg, word, word) // value, id

// low-level control flow
X(node, Label)
X(node, Mark, word)
X(node, Branch, word, word) // label, condition
X(node, Jump, word)

// type constructors
X(node, Int, word) // negative signed, positive unsigned, absolute value = number of bits; 0 = boolean
X(node, Float, word, word, word, word) // base, min exponent, max exponent, significant digits
X(node, Array, word, word) // element type, size
X(node, Struct, args) // layout should be compatible with C structs on the platform
X(node, Tuple, args)  // layout undefined, pointers to members allowed
X(node, Packed, args) // layout optimized for smallest reasonable memory footprint
X(node, Union, args)
X(node, Ptr, word)
X(node, Fun, word, word, args) // calling convention id (0 = default), return type (-1 = none), argument types

// constants
X(node, Imm, word) // immediate integer
X(node, Str, args) // args are the characters
X(node, Data, word, args) // type of the data (Tuple, Struct, Packed, or Array), elements in order

// calling conventions
X(node, Invoke, word, args)
X(node, Enter, word) // argument is the type of the function, i.e. a Fun node; result is an object of the type
X(node, Exit, word) // function to exit
X(node, Arg, word, word) // function whose argument to read, index
X(node, RVal, word) // function
